<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Num-Aut-Imag — YOLOv8n ONNX</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:16px;background:#fafafa;color:#111}
    .card{background:#fff;border:1px solid #ddd;border-radius:14px;padding:14px;max-width:820px;margin:0 auto}
    h1{font-size:24px;margin:0 0 10px}
    button{padding:10px 12px;border-radius:12px;border:1px solid #bbb;background:#f4f4f4}
    button.primary{background:#111;color:#fff;border-color:#111}
    button:disabled{opacity:.5}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .small{font-size:13px;color:#444}
    .ok{color:#0a7a2f;font-weight:700}
    .bad{color:#b00020;font-weight:700}
    canvas{max-width:100%;border:1px solid #ddd;border-radius:14px}
    input[type="file"]{max-width:100%}
    pre{white-space:pre-wrap;background:#0b1020;color:#e9eefc;padding:10px;border-radius:12px;max-height:260px;overflow:auto}
    label{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div class="card">
    <h1>Num-Aut-Imag — YOLOv8n ONNX</h1>

    <div class="small">
      Stato: <span id="status">Pronto</span><br/>
      Modello: <code id="modelPath">./yolov8n.onnx</code>
    </div>

    <hr/>

    <div class="row">
      <button id="btnLoadModel" class="primary">1) Carica modello</button>
      <input id="imgInput" type="file" accept="image/*" />
      <button id="btnRun" class="primary" disabled>2) Analizza immagine</button>
      <button id="btnClear">Pulisci</button>
    </div>

    <div class="row" style="margin-top:10px">
      <label>Confidenza:
        <input id="conf" type="range" min="0" max="1" step="0.01" value="0.35"/>
        <span id="confV">0.35</span>
      </label>
      <label>NMS IoU:
        <input id="iou" type="range" min="0" max="1" step="0.01" value="0.45"/>
        <span id="iouV">0.45</span>
      </label>
      <label style="margin-left:auto">Mostra %:
        <input id="showPct" type="checkbox" checked />
      </label>
    </div>

    <p class="small">
      Premi “Carica modello”, scegli una foto, poi “Analizza immagine”.
      Risultato: box + numeri progressivi 1..N sugli oggetti.
    </p>

    <canvas id="cv"></canvas>

    <h3 style="margin:14px 0 6px">Log</h3>
    <pre id="log"></pre>
  </div>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
    // ===== Utils =====
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    function log(...a){ logEl.textContent += a.join(" ") + "\n"; logEl.scrollTop = logEl.scrollHeight; }
    function setStatus(txt, ok=null){
      const s = $("status");
      s.textContent = txt;
      s.className = ok===true ? "ok" : ok===false ? "bad" : "";
    }

    // ===== State =====
    let session = null;
    let modelReady = false;
    let imageReady = false;
    let imgBitmap = null;

    const MODEL_URL = "./yolov8n.onnx?v=" + Date.now(); // anti-cache

    // ===== UI =====
    $("conf").addEventListener("input", ()=> $("confV").textContent = (+$("conf").value).toFixed(2));
    $("iou").addEventListener("input",  ()=> $("iouV").textContent  = (+$("iou").value).toFixed(2));

    function updateRunEnabled(){
      $("btnRun").disabled = !(modelReady && imageReady);
    }

    // ===== Canvas draw =====
    const cv = $("cv");
    const ctx = cv.getContext("2d");

    function drawImageToCanvas(bitmap){
      const maxW = 800;
      const scale = Math.min(1, maxW / bitmap.width);
      cv.width  = Math.round(bitmap.width * scale);
      cv.height = Math.round(bitmap.height * scale);
      ctx.clearRect(0,0,cv.width,cv.height);
      ctx.drawImage(bitmap, 0, 0, cv.width, cv.height);
    }

    // ===== Model load =====
    async function loadModel(){
      try{
        logEl.textContent = "";
        setStatus("Carico modello...", null);
        log("ORT version:", (window.ort && ort.version) ? ort.version : "unknown");

        // Android-safe
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = false;
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";

        log("Android-safe:", "simd=false,", "threads=1");
        log("Carico modello:", MODEL_URL);

        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: ["wasm"]
        });

        log("✅ Modello locale (yolov8n.onnx) OK");
        log("✅ Sessione creata!");
        log("Inputs:", JSON.stringify(session.inputNames));
        log("Outputs:", JSON.stringify(session.outputNames));

        modelReady = true;
        setStatus("Modello OK ✅ Ora scegli una foto", true);
        updateRunEnabled();

      }catch(e){
        console.error(e);
        modelReady = false;
        session = null;
        setStatus("Errore modello ❌", false);
        log("❌ ERRORE:", e?.message || e);
      }
    }

    $("btnLoadModel").addEventListener("click", loadModel);

    // ===== Image load =====
    $("imgInput").addEventListener("change", async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if(!f){ imageReady=false; updateRunEnabled(); return; }
        imgBitmap = await createImageBitmap(f);
        imageReady = true;
        drawImageToCanvas(imgBitmap);
        log(`Immagine caricata: ${f.name} ${imgBitmap.width}x${imgBitmap.height}`);
        updateRunEnabled();
      }catch(e){
        console.error(e);
        imageReady = false;
        imgBitmap = null;
        log("❌ Errore immagine:", e?.message || e);
        updateRunEnabled();
      }
    });

    // ===== Preprocess to 640x640 NCHW float32 =====
    function preprocess(bitmap, size=640){
      const off = document.createElement("canvas");
      off.width = size; off.height = size;
      const octx = off.getContext("2d");

      // stretch 640x640 (robusto e semplice)
      octx.drawImage(bitmap, 0, 0, size, size);

      const imgData = octx.getImageData(0,0,size,size).data;
      const chw = new Float32Array(1 * 3 * size * size);

      let p = 0;
      const area = size * size;
      for(let i=0;i<area;i++){
        const r = imgData[p] / 255;
        const g = imgData[p+1] / 255;
        const b = imgData[p+2] / 255;
        chw[i] = r;
        chw[i + area] = g;
        chw[i + area*2] = b;
        p += 4;
      }
      return {tensor: new ort.Tensor("float32", chw, [1,3,size,size]), size};
    }

    // ===== Postprocess =====
    function iou(a,b){
      const x1 = Math.max(a.x1,b.x1), y1=Math.max(a.y1,b.y1);
      const x2 = Math.min(a.x2,b.x2), y2=Math.min(a.y2,b.y2);
      const w = Math.max(0, x2-x1), h=Math.max(0,y2-y1);
      const inter = w*h;
      const areaA=(a.x2-a.x1)*(a.y2-a.y1);
      const areaB=(b.x2-b.x1)*(b.y2-b.y1);
      return inter/(areaA+areaB-inter+1e-9);
    }

    function nms(boxes, iouThr){
      boxes.sort((a,b)=>b.score-a.score);
      const out=[];
      for(const b of boxes){
        let keep=true;
        for(const o of out){
          if(iou(b,o)>iouThr){ keep=false; break; }
        }
        if(keep) out.push(b);
      }
      return out;
    }

    // Output tipico Ultralytics: [1,84,8400] oppure [1,8400,84]
    function decodeYOLO(outputTensor, confThr){
      const data = outputTensor.data;
      const dims = outputTensor.dims;
      log("Output dims:", JSON.stringify(dims), "len:", data.length);

      let C, N, layout;
      if(dims.length === 3){
        if(dims[1] < dims[2]){
          C = dims[1]; N = dims[2]; layout = "1CN";
        }else{
          N = dims[1]; C = dims[2]; layout = "1NC";
        }
      } else {
        return [];
      }

      const numClasses = C - 4;
      const boxes = [];

      for(let i=0;i<N;i++){
        let x,y,w,h;
        if(layout==="1CN"){
          x = data[0*N + i];
          y = data[1*N + i];
          w = data[2*N + i];
          h = data[3*N + i];

          let best=-1, bestScore=0;
          for(let c=0;c<numClasses;c++){
            const s = data[(4+c)*N + i];
            if(s>bestScore){ bestScore=s; best=c; }
          }
          const score = bestScore;
          if(score >= confThr){
            boxes.push({cx:x, cy:y, w:w, h:h, cls:best, score});
          }
        } else {
          const base = i*C;
          x = data[base+0]; y=data[base+1]; w=data[base+2]; h=data[base+3];

          let best=-1, bestScore=0;
          for(let c=0;c<numClasses;c++){
            const s = data[base+4+c];
            if(s>bestScore){ bestScore=s; best=c; }
          }
          const score = bestScore;
          if(score >= confThr){
            boxes.push({cx:x, cy:y, w:w, h:h, cls:best, score});
          }
        }
      }
      return boxes;
    }

    // ===== NUMERAZIONE: ordine umano =====
    function sortForNumbering(boxesInCanvas){
      // Ordina: prima per riga (y), poi per x
      // Soglia riga dinamica (in base al canvas) -> più robusto su foto diverse
      const rowTol = Math.max(18, Math.round(cv.height * 0.03)); // ~3% altezza o min 18px

      return boxesInCanvas.slice().sort((a,b)=>{
        const dy = a.ry - b.ry;
        if(Math.abs(dy) > rowTol) return dy;
        return a.rx - b.rx;
      });
    }

    function drawNumberBadge(x, y, n, showPct=false, pctText=""){
      // cerchio rosso + numero bianco
      const r = 12;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(n), x, y);

      if(showPct && pctText){
        // piccola etichetta sotto
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        const pad = 4;
        const tw = ctx.measureText(pctText).width + pad*2;
        const th = 16;
        ctx.fillRect(x - r, y + r + 4, tw, th);
        ctx.fillStyle = "#fff";
        ctx.fillText(pctText, x - r + pad, y + r + 6);
      }
    }

    function drawBoxesAndNumbers(bitmap, boxes, inputSize=640){
      drawImageToCanvas(bitmap);

      // conversioni coordinate
      const scaleX = cv.width / bitmap.width;
      const scaleY = cv.height / bitmap.height;

      // box nel sistema 640x640 -> riportiamo a bitmap
      const sx = bitmap.width / inputSize;
      const sy = bitmap.height / inputSize;

      // Prima creiamo una lista di box in coordinate canvas
      const canvasBoxes = boxes.map(b=>{
        const x1 = (b.cx - b.w/2) * sx;
        const y1 = (b.cy - b.h/2) * sy;
        const x2 = (b.cx + b.w/2) * sx;
        const y2 = (b.cy + b.h/2) * sy;

        const rx = x1 * scaleX;
        const ry = y1 * scaleY;
        const rw = (x2-x1) * scaleX;
        const rh = (y2-y1) * scaleY;

        return { ...b, rx, ry, rw, rh };
      });

      // Disegno box
      ctx.lineWidth = 2;
      for(const b of canvasBoxes){
        ctx.strokeStyle = "#00a000";
        ctx.fillStyle = "rgba(0,160,0,0.15)";
        ctx.fillRect(b.rx,b.ry,b.rw,b.rh);
        ctx.strokeRect(b.rx,b.ry,b.rw,b.rh);
      }

      // Ordina e NUMERA
      const ordered = sortForNumbering(canvasBoxes);
      const showPct = $("showPct").checked;

      let n = 1;
      for(const b of ordered){
        const pct = `${(b.score*100).toFixed(0)}%`;
        // badge in alto a sinistra della box
        const bx = b.rx + 14;
        const by = b.ry + 14;
        drawNumberBadge(bx, by, n++, showPct, showPct ? pct : "");
      }
    }

    // ===== Run inference =====
    async function run(){
      try{
        if(!modelReady || !imageReady || !session){
          alert("Prima carica il modello e scegli una foto.");
          return;
        }

        setStatus("Analizzo immagine...", null);
        log("---- RUN ----");

        const confThr = +$("conf").value;
        const iouThr = +$("iou").value;

        const {tensor} = preprocess(imgBitmap, 640);
        log("Preprocess OK, tensor dims:", JSON.stringify(tensor.dims));

        const feeds = {};
        feeds[session.inputNames[0]] = tensor;

        const t0 = performance.now();
        const results = await session.run(feeds);
        const t1 = performance.now();
        log(`Inference OK in ${(t1-t0).toFixed(0)} ms`);

        const outName = session.outputNames[0];
        const out = results[outName];
        if(!out) throw new Error("Output mancante: " + outName);

        const raw = decodeYOLO(out, confThr);

        const boxes = raw.map(b => ({
          ...b,
          x1: b.cx - b.w/2,
          y1: b.cy - b.h/2,
          x2: b.cx + b.w/2,
          y2: b.cy + b.h/2
        }));

        const finalBoxes = nms(boxes, iouThr);
        log("Detections raw:", raw.length, "after NMS:", finalBoxes.length);

        // === QUI: box + numerazione 1..N ===
        drawBoxesAndNumbers(imgBitmap, finalBoxes, 640);

        setStatus(`Analisi completata ✅ Numerati: ${finalBoxes.length}`, true);
      }catch(e){
        console.error(e);
        setStatus("Errore analisi ❌", false);
        log("❌ ERRORE ANALISI:", e?.message || e);
        alert("Errore durante analisi: " + (e?.message || e));
      }
    }

    $("btnRun").addEventListener("click", run);

    $("btnClear").addEventListener("click", ()=>{
      logEl.textContent = "";
      ctx.clearRect(0,0,cv.width,cv.height);
      imageReady=false; imgBitmap=null;
      $("imgInput").value = "";
      updateRunEnabled();
      setStatus(modelReady ? "Modello OK ✅ Ora scegli una foto" : "Pronto", modelReady);
    });
  </script>
</body>
</html>
