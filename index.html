<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Num-Aut-Imag ‚Äî YOLOv8n ONNX</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:16px;background:#fafafa;color:#111}
    .card{background:#fff;border:1px solid #ddd;border-radius:14px;padding:14px;max-width:1100px;margin:0 auto}
    h1{font-size:24px;margin:0 0 10px}
    button{padding:10px 12px;border-radius:12px;border:1px solid #bbb;background:#f4f4f4}
    button.primary{background:#111;color:#fff;border-color:#111}
    button:disabled{opacity:.5}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .small{font-size:13px;color:#444}
    .ok{color:#0a7a2f;font-weight:700}
    .bad{color:#b00020;font-weight:700}
    canvas{max-width:100%;border:1px solid #ddd;border-radius:14px;touch-action:manipulation}
    input[type="file"]{max-width:100%}
    input[type="number"]{width:90px;padding:8px;border-radius:10px;border:1px solid #bbb}
    pre{white-space:pre-wrap;background:#0b1020;color:#e9eefc;padding:10px;border-radius:12px;max-height:260px;overflow:auto}
    label{display:flex;gap:8px;align-items:center}
    .pill{display:inline-block;padding:6px 10px;border:1px solid #ddd;border-radius:999px;background:#f7f7f7}
    .pill b{font-size:14px}
    .hint{opacity:.9}
  </style>
</head>
<body>
  <div class="card">
    <h1>Num-Aut-Imag ‚Äî YOLOv8n ONNX</h1>

    <div class="small">
      Stato: <span id="status">Pronto</span><br/>
      Modello: <code id="modelPath">./yolov8n.onnx</code>
    </div>

    <hr/>

    <div class="row">
      <button id="btnLoadModel" class="primary">1) Carica modello</button>
      <input id="imgInput" type="file" accept="image/*" />
      <button id="btnRun" class="primary" disabled>2) Analizza immagine</button>
      <button id="btnClear">Pulisci</button>

      <span class="pill">AI: <b id="totalAi">0</b></span>
      <span class="pill">Manuali: <b id="totalManual">0</b></span>
      <span class="pill">Totale: <b id="totalAll">0</b></span>
    </div>

    <div class="row" style="margin-top:10px">
      <label>Confidenza:
        <input id="conf" type="range" min="0" max="1" step="0.01" value="0.35"/>
        <span id="confV">0.35</span>
      </label>
      <label>NMS IoU:
        <input id="iou" type="range" min="0" max="1" step="0.01" value="0.45"/>
        <span id="iouV">0.45</span>
      </label>

      <label style="margin-left:auto">Inizia da:
        <input id="startNum" type="number" min="1" step="1" value="1" />
      </label>

      <label>Mostra %:
        <input id="showPct" type="checkbox" checked />
      </label>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnDlPng" disabled>‚¨áÔ∏è PNG</button>
      <button id="btnDlJpg" disabled>‚¨áÔ∏è JPG</button>
      <button id="btnDlCsv" disabled>‚¨áÔ∏è CSV (numero+classe)</button>

      <span class="pill hint">Manuale:
        <label style="margin-left:10px">ON <input id="manualMode" type="checkbox" disabled /></label>
      </span>
      <span class="pill hint">Prossimo # <b id="nextManual">-</b></span>

      <button id="btnUndoManual" disabled>‚Ü©Ô∏è Annulla ultimo</button>
      <button id="btnClearManual" disabled>üßπ Pulisci manuali</button>
    </div>

    <p class="small hint">
      Dopo l‚Äôanalisi puoi attivare <b>Manuale ON</b> e poi <b>toccare sull‚Äôimmagine</b> per aggiungere numeri dove l‚ÄôAI non ha trovato oggetti.
    </p>

    <canvas id="cv"></canvas>

    <h3 style="margin:14px 0 6px">Log</h3>
    <pre id="log"></pre>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
    // ===== COCO 80 class names (YOLOv8n default) =====
    const COCO80 = [
      "person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light",
      "fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow",
      "elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee",
      "skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket","bottle",
      "wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange",
      "broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed",
      "dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven",
      "toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"
    ];

    // ===== Utils =====
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    function log(...a){ logEl.textContent += a.join(" ") + "\n"; logEl.scrollTop = logEl.scrollHeight; }
    function setStatus(txt, ok=null){
      const s = $("status");
      s.textContent = txt;
      s.className = ok===true ? "ok" : ok===false ? "bad" : "";
    }
    function pad2(n){ return String(n).padStart(2,"0"); }
    function ts(){
      const d = new Date();
      return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}_${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
    }
    function downloadDataUrl(dataUrl, filename){
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    function downloadText(text, filename){
      const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    // ===== State =====
    let session = null;
    let modelReady = false;
    let imageReady = false;
    let imgBitmap = null;

    let lastResultReady = false;

    // Risultati AI gi√† ordinati e numerati (per CSV)
    let lastNumberedAi = [];   // {num, clsId, clsName, score, rx,ry,rw,rh}
    // Numeri manuali aggiunti dall‚Äôutente
    let manualMarkers = [];    // {num, x, y} in coordinate canvas

    let nextManualNumber = 1;

    const MODEL_URL = "./yolov8n.onnx?v=" + Date.now(); // anti-cache

    // ===== UI =====
    $("conf").addEventListener("input", ()=> $("confV").textContent = (+$("conf").value).toFixed(2));
    $("iou").addEventListener("input",  ()=> $("iouV").textContent  = (+$("iou").value).toFixed(2));

    function updateTotals(){
      $("totalAi").textContent = String(lastNumberedAi.length);
      $("totalManual").textContent = String(manualMarkers.length);
      $("totalAll").textContent = String(lastNumberedAi.length + manualMarkers.length);
    }

    function updateButtons(){
      $("btnRun").disabled = !(modelReady && imageReady);

      $("btnDlPng").disabled = !lastResultReady;
      $("btnDlJpg").disabled = !lastResultReady;
      $("btnDlCsv").disabled = !lastResultReady;

      // manual controls active only after analysis
      $("manualMode").disabled = !lastResultReady;
      $("btnUndoManual").disabled = !lastResultReady || manualMarkers.length === 0;
      $("btnClearManual").disabled = !lastResultReady || manualMarkers.length === 0;

      $("nextManual").textContent = lastResultReady ? String(nextManualNumber) : "-";
      updateTotals();
    }

    // ===== Canvas =====
    const cv = $("cv");
    const ctx = cv.getContext("2d");

    function drawImageToCanvas(bitmap){
      const maxW = 980;
      const scale = Math.min(1, maxW / bitmap.width);
      cv.width  = Math.round(bitmap.width * scale);
      cv.height = Math.round(bitmap.height * scale);
      ctx.clearRect(0,0,cv.width,cv.height);
      ctx.drawImage(bitmap, 0, 0, cv.width, cv.height);
    }

    function getCanvasPos(ev){
      const rect = cv.getBoundingClientRect();
      const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
      const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
      const x = (clientX - rect.left) * (cv.width / rect.width);
      const y = (clientY - rect.top)  * (cv.height / rect.height);
      return {x,y};
    }

    // ===== Drawing helpers =====
    function drawNumberBadge(x, y, n, showPct=false, pctText=""){
      const r = 12;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(n), x, y);

      if(showPct && pctText){
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        const pad = 4;
        const tw = ctx.measureText(pctText).width + pad*2;
        const th = 16;
        ctx.fillRect(x - r, y + r + 4, tw, th);
        ctx.fillStyle = "#fff";
        ctx.fillText(pctText, x - r + pad, y + r + 6);
      }
    }

    function redrawAll(){
      if(!imgBitmap) return;
      drawImageToCanvas(imgBitmap);

      // 1) draw AI boxes
      ctx.lineWidth = 2;
      for(const b of lastNumberedAi){
        ctx.strokeStyle = "#00a000";
        ctx.fillStyle = "rgba(0,160,0,0.15)";
        ctx.fillRect(b.rx,b.ry,b.rw,b.rh);
        ctx.strokeRect(b.rx,b.ry,b.rw,b.rh);
      }

      // 2) draw AI numbers
      const showPct = $("showPct").checked;
      for(const b of lastNumberedAi){
        const pct = `${(b.score*100).toFixed(0)}%`;
        drawNumberBadge(b.rx + 14, b.ry + 14, b.num, showPct, showPct ? pct : "");
      }

      // 3) draw manual markers (blue)
      for(const m of manualMarkers){
        // blue badge
        const r = 12;
        ctx.fillStyle = "#0057ff";
        ctx.beginPath();
        ctx.arc(m.x, m.y, r, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(m.num), m.x, m.y);
      }
    }

    // ===== Manual mode clicks =====
    function onCanvasTap(ev){
      if(!$("manualMode").checked) return;
      if(!lastResultReady) return;
      ev.preventDefault();

      const {x,y} = getCanvasPos(ev);
      manualMarkers.push({ num: nextManualNumber, x, y });
      nextManualNumber += 1;

      redrawAll();
      updateButtons();
    }

    cv.addEventListener("click", onCanvasTap);
    cv.addEventListener("touchstart", onCanvasTap, {passive:false});

    $("btnUndoManual").addEventListener("click", ()=>{
      if(manualMarkers.length === 0) return;
      const last = manualMarkers.pop();
      // riportiamo indietro il contatore solo se era l‚Äôultimo numero
      if(last && last.num === nextManualNumber - 1){
        nextManualNumber -= 1;
      }
      redrawAll();
      updateButtons();
    });

    $("btnClearManual").addEventListener("click", ()=>{
      manualMarkers = [];
      // riparte dopo l‚Äôultimo numero AI
      nextManualNumber = (lastNumberedAi.length ? (lastNumberedAi[lastNumberedAi.length-1].num + 1) : parseInt($("startNum").value || "1",10));
      redrawAll();
      updateButtons();
    });

    // ===== Download =====
    $("btnDlPng").addEventListener("click", ()=>{
      downloadDataUrl(cv.toDataURL("image/png"), `Num-Aut-Imag_${ts()}.png`);
    });
    $("btnDlJpg").addEventListener("click", ()=>{
      downloadDataUrl(cv.toDataURL("image/jpeg", 0.92), `Num-Aut-Imag_${ts()}.jpg`);
    });
    $("btnDlCsv").addEventListener("click", ()=>{
      if(!lastResultReady){
        alert("Prima fai Analizza.");
        return;
      }

      // CSV: numero,classe,confidenza,tipo,x,y,w,h
      // - AI: classe = nome, confidenza = score, tipo = ai, x/y/w/h = box canvas
      // - Manuale: classe = manual, confidenza vuoto, tipo = manual, x/y = marker, w/h vuoti
      const header = "numero,classe,confidenza,tipo,x,y,w,h\n";
      const rows = [];

      for(const b of lastNumberedAi){
        rows.push([
          b.num,
          `"${(b.clsName || ("cls_"+b.clsId)).replace(/"/g,'""')}"`,
          b.score.toFixed(4),
          "ai",
          b.rx.toFixed(1),
          b.ry.toFixed(1),
          b.rw.toFixed(1),
          b.rh.toFixed(1)
        ].join(","));
      }

      for(const m of manualMarkers){
        rows.push([
          m.num,
          `"manual"`,
          "",
          "manual",
          m.x.toFixed(1),
          m.y.toFixed(1),
          "",
          ""
        ].join(","));
      }

      downloadText(header + rows.join("\n") + "\n", `Num-Aut-Imag_${ts()}.csv`);
    });

    // ===== Model load =====
    async function loadModel(){
      try{
        logEl.textContent = "";
        setStatus("Carico modello...", null);
        log("ORT version:", (window.ort && ort.version) ? ort.version : "unknown");

        // Android-safe
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = false;
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";

        log("Android-safe:", "simd=false,", "threads=1");
        log("Carico modello:", MODEL_URL);

        session = await ort.InferenceSession.create(MODEL_URL, { executionProviders: ["wasm"] });

        log("‚úÖ Modello OK");
        log("‚úÖ Sessione creata!");
        log("Inputs:", JSON.stringify(session.inputNames));
        log("Outputs:", JSON.stringify(session.outputNames));

        modelReady = true;
        setStatus("Modello OK ‚úÖ Ora scegli una foto", true);
        updateButtons();

      }catch(e){
        console.error(e);
        modelReady = false;
        session = null;
        setStatus("Errore modello ‚ùå", false);
        log("‚ùå ERRORE:", e?.message || e);
        updateButtons();
      }
    }
    $("btnLoadModel").addEventListener("click", loadModel);

    // ===== Image load =====
    $("imgInput").addEventListener("change", async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if(!f){ imageReady=false; updateButtons(); return; }
        imgBitmap = await createImageBitmap(f);
        imageReady = true;

        // reset risultati
        lastResultReady = false;
        lastNumberedAi = [];
        manualMarkers = [];
        nextManualNumber = parseInt($("startNum").value || "1", 10) || 1;
        $("manualMode").checked = false;

        drawImageToCanvas(imgBitmap);
        log(`Immagine: ${f.name} ${imgBitmap.width}x${imgBitmap.height}`);
        setStatus(modelReady ? "Modello OK ‚úÖ Ora analizza" : "Carica modello", modelReady ? true : null);
        updateButtons();
      }catch(e){
        console.error(e);
        imageReady = false;
        imgBitmap = null;
        lastResultReady = false;
        lastNumberedAi = [];
        manualMarkers = [];
        $("manualMode").checked = false;
        log("‚ùå Errore immagine:", e?.message || e);
        updateButtons();
      }
    });

    // ===== Preprocess =====
    function preprocess(bitmap, size=640){
      const off = document.createElement("canvas");
      off.width = size; off.height = size;
      const octx = off.getContext("2d");
      octx.drawImage(bitmap, 0, 0, size, size);

      const imgData = octx.getImageData(0,0,size,size).data;
      const chw = new Float32Array(1 * 3 * size * size);

      let p = 0;
      const area = size * size;
      for(let i=0;i<area;i++){
        chw[i] = imgData[p] / 255;
        chw[i + area] = imgData[p+1] / 255;
        chw[i + area*2] = imgData[p+2] / 255;
        p += 4;
      }
      return {tensor: new ort.Tensor("float32", chw, [1,3,size,size]), size};
    }

    // ===== Postprocess =====
    function iou(a,b){
      const x1 = Math.max(a.x1,b.x1), y1=Math.max(a.y1,b.y1);
      const x2 = Math.min(a.x2,b.x2), y2=Math.min(a.y2,b.y2);
      const w = Math.max(0, x2-x1), h=Math.max(0,y2-y1);
      const inter = w*h;
      const areaA=(a.x2-a.x1)*(a.y2-a.y1);
      const areaB=(b.x2-b.x1)*(b.y2-b.y1);
      return inter/(areaA+areaB-inter+1e-9);
    }
    function nms(boxes, iouThr){
      boxes.sort((a,b)=>b.score-a.score);
      const out=[];
      for(const b of boxes){
        let keep=true;
        for(const o of out){
          if(iou(b,o)>iouThr){ keep=false; break; }
        }
        if(keep) out.push(b);
      }
      return out;
    }

    function decodeYOLO(outputTensor, confThr){
      const data = outputTensor.data;
      const dims = outputTensor.dims;
      log("Output dims:", JSON.stringify(dims), "len:", data.length);

      let C, N, layout;
      if(dims.length === 3){
        if(dims[1] < dims[2]){
          C = dims[1]; N = dims[2]; layout = "1CN";
        }else{
          N = dims[1]; C = dims[2]; layout = "1NC";
        }
      } else return [];

      const numClasses = C - 4;
      const boxes = [];

      for(let i=0;i<N;i++){
        let x,y,w,h,score,clsId;
        if(layout==="1CN"){
          x = data[0*N + i];
          y = data[1*N + i];
          w = data[2*N + i];
          h = data[3*N + i];

          let best=-1, bestScore=0;
          for(let c=0;c<numClasses;c++){
            const s = data[(4+c)*N + i];
            if(s>bestScore){ bestScore=s; best=c; }
          }
          score = bestScore; clsId = best;
        } else {
          const base = i*C;
          x = data[base+0]; y=data[base+1]; w=data[base+2]; h=data[base+3];

          let best=-1, bestScore=0;
          for(let c=0;c<numClasses;c++){
            const s = data[base+4+c];
            if(s>bestScore){ bestScore=s; best=c; }
          }
          score = bestScore; clsId = best;
        }

        if(score >= confThr){
          boxes.push({cx:x, cy:y, w:w, h:h, clsId, score});
        }
      }
      return boxes;
    }

    // ordine umano: alto->basso, sinistra->destra
    function sortForNumbering(canvasBoxes){
      const rowTol = Math.max(18, Math.round(cv.height * 0.03));
      return canvasBoxes.slice().sort((a,b)=>{
        const dy = a.ry - b.ry;
        if(Math.abs(dy) > rowTol) return dy;
        return a.rx - b.rx;
      });
    }

    // ===== Run inference =====
    async function run(){
      try{
        if(!modelReady || !imageReady || !session){
          alert("Prima carica il modello e scegli una foto.");
          return;
        }

        setStatus("Analizzo immagine...", null);
        log("---- RUN ----");

        // reset manual every new analysis
        manualMarkers = [];
        $("manualMode").checked = false;

        const confThr = +$("conf").value;
        const iouThr = +$("iou").value;

        const {tensor} = preprocess(imgBitmap, 640);
        log("Preprocess OK, tensor dims:", JSON.stringify(tensor.dims));

        const feeds = {};
        feeds[session.inputNames[0]] = tensor;

        const t0 = performance.now();
        const results = await session.run(feeds);
        const t1 = performance.now();
        log(`Inference OK in ${(t1-t0).toFixed(0)} ms`);

        const outName = session.outputNames[0];
        const out = results[outName];
        if(!out) throw new Error("Output mancante: " + outName);

        const raw = decodeYOLO(out, confThr);

        // x1y1x2y2 for NMS
        const boxes = raw.map(b => ({
          ...b,
          x1: b.cx - b.w/2,
          y1: b.cy - b.h/2,
          x2: b.cx + b.w/2,
          y2: b.cy + b.h/2
        }));

        const finalBoxes = nms(boxes, iouThr);
        log("Detections raw:", raw.length, "after NMS:", finalBoxes.length);

        // convert to canvas coords
        drawImageToCanvas(imgBitmap);
        const inputSize = 640;

        const scaleX = cv.width / imgBitmap.width;
        const scaleY = cv.height / imgBitmap.height;
        const sx = imgBitmap.width / inputSize;
        const sy = imgBitmap.height / inputSize;

        const canvasBoxes = finalBoxes.map(b=>{
          const x1 = (b.cx - b.w/2) * sx;
          const y1 = (b.cy - b.h/2) * sy;
          const x2 = (b.cx + b.w/2) * sx;
          const y2 = (b.cy + b.h/2) * sy;

          const rx = x1 * scaleX;
          const ry = y1 * scaleY;
          const rw = (x2-x1) * scaleX;
          const rh = (y2-y1) * scaleY;

          const clsName = COCO80[b.clsId] || ("cls_"+b.clsId);
          return { ...b, clsName, rx, ry, rw, rh };
        });

        // sort + numbering
        const ordered = sortForNumbering(canvasBoxes);

        let start = parseInt($("startNum").value || "1", 10);
        if(!Number.isFinite(start) || start < 1) start = 1;

        lastNumberedAi = [];
        let n = start;
        for(const b of ordered){
          lastNumberedAi.push({
            num: n,
            clsId: b.clsId,
            clsName: b.clsName,
            score: b.score,
            rx: b.rx, ry: b.ry, rw: b.rw, rh: b.rh
          });
          n++;
        }

        // manual numbers continue after last AI number
        nextManualNumber = (lastNumberedAi.length ? (lastNumberedAi[lastNumberedAi.length-1].num + 1) : start);

        lastResultReady = true;
        redrawAll();

        setStatus(`Analisi completata ‚úÖ Totale AI: ${lastNumberedAi.length}`, true);
        updateButtons();

      }catch(e){
        console.error(e);
        lastResultReady = false;
        lastNumberedAi = [];
        manualMarkers = [];
        nextManualNumber = parseInt($("startNum").value || "1", 10) || 1;
        redrawAll();
        setStatus("Errore analisi ‚ùå", false);
        log("‚ùå ERRORE ANALISI:", e?.message || e);
        alert("Errore durante analisi: " + (e?.message || e));
        updateButtons();
      }
    }

    $("btnRun").addEventListener("click", run);

    $("btnClear").addEventListener("click", ()=>{
      logEl.textContent = "";
      ctx.clearRect(0,0,cv.width,cv.height);
      imageReady=false; imgBitmap=null;
      lastResultReady=false;
      lastNumberedAi=[];
      manualMarkers=[];
      nextManualNumber = parseInt($("startNum").value || "1", 10) || 1;
      $("imgInput").value = "";
      $("manualMode").checked = false;
      setStatus(modelReady ? "Modello OK ‚úÖ Ora scegli una foto" : "Pronto", modelReady ? true : null);
      updateButtons();
    });

    // init
    updateButtons();
    updateTotals();
  </script>
</body>
</html>
