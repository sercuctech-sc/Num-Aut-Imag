.< !doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Num-Aut-Imag — YOLOv8n ONNX (Android-safe)</title>

  <base href="/Num-Aut-Imag/">

  <style>
    body { font-family: Roboto, Arial, sans-serif; padding: 14px; }
    h1 { margin: 0 0 10px; font-size: 26px; }
    .box { padding:12px; border:1px solid #ddd; border-radius:14px; margin:12px 0; }
    pre { background:#f5f5f5; padding:12px; border-radius:14px; white-space:pre-wrap; overflow:auto; max-height: 260px; }
    button { padding:10px 12px; border-radius:12px; border:1px solid #ccc; background:#fff; font-size:16px; }
    input[type="file"] { font-size:16px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .ok { color:#0a7a1f; font-weight:700; }
    .bad { color:#8b0000; font-weight:700; }
    code { background:#f3f3f3; padding:2px 6px; border-radius:6px; }
    canvas { width: 100%; height: auto; border-radius: 12px; background:#fafafa; border:1px solid #eee; }
    .muted { color:#666; font-size: 13px; }
  </style>
</head>

<body>
  <h1>Num-Aut-Imag — YOLOv8n ONNX</h1>

  <div class="box">
    Stato: <span id="state">Pronto ✅</span>
    <div class="muted" style="margin-top:6px;">
      Modello: <code id="modelPath">./yolov8n.onnx</code>
    </div>
  </div>

  <div class="box">
    <div class="row">
      <button id="btnLoad">1) Carica modello</button>
      <input type="file" id="imgInput" accept="image/*" disabled />
      <button id="btnDetect" disabled>2) Analizza immagine</button>
      <button id="btnClear">Pulisci</button>
    </div>
    <p class="muted" style="margin:10px 0 0;">
      Se resta su “Carico modello…” guarda il log: qui sotto ti dice esattamente cosa manca (WASM o ONNX).
    </p>
  </div>

  <div class="box">
    <canvas id="canvas"></canvas>
  </div>

  <pre id="log">Log pronto…\n</pre>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
    const stateEl = document.getElementById('state');
    const logEl = document.getElementById('log');
    const modelPathEl = document.getElementById('modelPath');

    const btnLoad = document.getElementById('btnLoad');
    const btnDetect = document.getElementById('btnDetect');
    const btnClear = document.getElementById('btnClear');
    const imgInput = document.getElementById('imgInput');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const MODEL_URL = "./yolov8n.onnx";
    modelPathEl.textContent = MODEL_URL;

    let session = null;
    let currentImage = null;
    let currentImageURL = null;

    function log(...args) {
      console.log(...args);
      logEl.textContent += args.map(x => {
        if (x instanceof Error) return (x.stack || x.message || String(x));
        if (typeof x === 'object') return JSON.stringify(x, null, 2);
        return String(x);
      }).join(' ') + '\n';
    }

    // Anti pagina bianca
    window.addEventListener('error', (e) => {
      stateEl.className = "bad";
      stateEl.textContent = "Errore JS ❌ (vedi log)";
      log("window.error:", e.message, (e.filename||"") + ":" + (e.lineno||"") + ":" + (e.colno||""));
      if (e.error) log(e.error);
    });
    window.addEventListener('unhandledrejection', (e) => {
      stateEl.className = "bad";
      stateEl.textContent = "Promise reject ❌ (vedi log)";
      log("unhandledrejection:", e.reason);
    });

    function drawPreview(img) {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      canvas.width = iw;
      canvas.height = ih;
      ctx.clearRect(0,0,iw,ih);
      ctx.drawImage(img, 0, 0);
    }

    imgInput.addEventListener('change', () => {
      const file = imgInput.files && imgInput.files[0];
      if (!file) return;

      if (currentImageURL) URL.revokeObjectURL(currentImageURL);
      currentImageURL = URL.createObjectURL(file);

      const img = new Image();
      img.onload = () => {
        currentImage = img;
        drawPreview(img);
        log("Immagine caricata:", file.name, `${img.naturalWidth}x${img.naturalHeight}`);
        btnDetect.disabled = !session;
      };
      img.onerror = () => log("Errore caricamento immagine.");
      img.src = currentImageURL;
    });

    btnClear.addEventListener('click', () => {
      logEl.textContent = "Log pronto…\n";
      stateEl.className = "";
      stateEl.textContent = "Pronto ✅";
      ctx.clearRect(0,0,canvas.width,canvas.height);
      canvas.width = 1; canvas.height = 1;
      currentImage = null;
      imgInput.value = "";
      btnDetect.disabled = true;
    });

    async function fetchCheck(url, label) {
      try {
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error(`${label} KO (HTTP ${r.status})`);
        log(`✅ ${label} OK`);
        return true;
      } catch (e) {
        log(`❌ ${label} KO:`, e);
        return false;
      }
    }

    function withTimeout(promise, ms, label="Timeout") {
      return Promise.race([
        promise,
        new Promise((_, rej) => setTimeout(() => rej(new Error(`${label}: ${ms}ms`)), ms))
      ]);
    }

    btnLoad.addEventListener('click', async () => {
      try {
        btnLoad.disabled = true;
        stateEl.className = "";
        stateEl.textContent = "Carico modello…";

        if (!window.ort) throw new Error("onnxruntime-web non caricato (ort undefined).");

        // Android-safe
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";
        ort.env.wasm.simd = false;
        ort.env.wasm.numThreads = 1;

        log("ORT OK");
        log("wasmPaths:", ort.env.wasm.wasmPaths);
        log("Android-safe: simd=false, threads=1");

        // ✅ Verifica che i WASM essenziali siano raggiungibili
        // (ne controlliamo 2: base e simd. Anche se simd è off, ci interessa capire se il CDN risponde bene)
        await fetchCheck(ort.env.wasm.wasmPaths + "ort-wasm.wasm", "WASM base (ort-wasm.wasm)");
        await fetchCheck(ort.env.wasm.wasmPaths + "ort-wasm-simd.wasm", "WASM simd (ort-wasm-simd.wasm)");

        // ✅ Verifica modello locale
        const okModel = await fetchCheck(MODEL_URL, "Modello locale (yolov8n.onnx)");
        if (!okModel) throw new Error("Il modello non è raggiungibile. Deve essere nella stessa cartella di index.html.");

        log("Creo sessione ORT (WASM)…");
        // ✅ forziamo wasm + timeout (così non resta infinito)
        session = await withTimeout(
          ort.InferenceSession.create(MODEL_URL, { executionProviders: ["wasm"] }),
          90000,
          "Creazione sessione troppo lenta"
        );

        log("✅ Sessione creata!");
        log("Inputs:", session.inputNames);
        log("Outputs:", session.outputNames);

        stateEl.className = "ok";
        stateEl.textContent = "Modello OK ✅ Ora scegli una foto";
        imgInput.disabled = false;
        btnDetect.disabled = !currentImage;
      } catch (e) {
        stateEl.className = "bad";
        stateEl.textContent = "KO ❌ (vedi log)";
        log("❌ ERRORE:", e);
        alert("Errore: " + (e?.message || e));
      } finally {
        btnLoad.disabled = false;
      }
    });

    // Per ora “Analizza immagine” lo lasciamo disattivato: prima facciamo partire il modello al 100%.
    btnDetect.addEventListener('click', () => {
      alert("Prima sistemiamo il caricamento del modello. Se vedi 'Modello OK ✅', poi procediamo con l'analisi.");
    });
  </script>
</body>
</html>
